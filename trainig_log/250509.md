# 🗓️ 2025.05.09 (금) – 교육 일지

## 📚 오늘 배운 내용

### Java

- 객체 지향 특징 3 : 다형성
  - 하나의 인스턴스가 여러 가지 타입을 가질 수 있는 것
  - 클래스 형변환
    - up-casting
      - 상위 클래스 타입으로 변환(자식 -> 부모)
      - 명시적, 묵시적 형변환 가능
      - 자식 클래스의 일반 메소드에는 접근 불가능 (부모 클래스는 자식 클래스를 모르기 때문)
      - 자식 클래스에서 오버라이딩된 메소드에만 접근이 가능하다
    - down-casting : 하위 클래스 타입으로 변환(부모 -> 자식) / 명시적 형변환만 가능
    - 예시
      ````
      /* Animal을 상속받은 Rabbit */
      
      // up-casting
      Animal animal1 = (Animal) new Rabbit(); // 명시적
      Animal animal2 = new Rabbit(); // 묵시적
      
      // down casting
      Rabbit animal2 = (Rabbit) new Animal();
      ````
  - 동적 바인딩과 정적 바인딩
    - 바인딩 : 컴퓨터 프로그램에서 각종 값들이 더 이상 변경되지 않는 값으로 구속 되는 것
    - 정적 바인딩 : 컴파일 과정에서 수행되는 바인딩 (예 : 메소드 오버로딩)
    - 동적 바인딩 : 런타임 과정에서 수행되는 바인딩 (예 : 객체의 다형성)
- 객체 지향 특징 4 : 추상화
  - 추상 클래스
    - 추상 메소드를 0개 이상 포함하는 클래스
    - 추상 클래스는 클래스 선언부에 abstract 키워드를 명시해야 한다.
    - 추상 클래스로는 인스턴스를 생성할 수 없다.
    - 추상 클래스를 사용하려면 추상클래스를 상속받은 하위 클래스를 이용해서 인스턴스를 생성해야 한다.
    - 추상클래스는 상위 타입으로 사용될 수 있으며, 다형성을 이용할 수 있다.
    - 추상클래스에 작성한 추상 메소드는 반드시 후손이 오버라이딩해서 작성해야 하며, 후손 클래스들의 메소드들의 공통 인터페이스로의 역할을 수행할 수 있다.
    - extends 키워드를 사용하여 추상 클래스를 상속 받는다.
  - 추상 메소드
    - 메소드의 선언부만 있고, 구현부가 없는 메소드를 추상 메소드
    - 추상 메소드의 경우 반드시 abstract 키워드를 메소드 헤드에 작성해야 함.
    - `public abstract void method();`
  - 추상 클래스 사용 이유
    - 추상 클래스의 추상메소드는 오버라이딩에 대한 강제성이 부여된다.
    -  따라서 여러 클래스들을 그룹화하여 필수 기능을 정의하여 강제성을 부여해 개발 시 일관된 인터페이스를 제공할 수 있다.
    - 하지만 다른 클래스를 상속 받고 있는 클래스를 작성할 시에는 추상 클래스를 추가로 상속받을 수 없다. 그래서 추상 클래스보다 더 강제성이 강한 인터페이스(interface)라는 매커니즘을 제공하고 있다.
- 인터페이스
  - 인스턴스 생성이 불가능하다.
  - 상수 필드만 작성이 가능하기 때문에 반드시 선언과 동시에 초기화 해줘야 한다.
  - 인터페이스에서의 모든 필드는 묵시적으로 `public static final`이다.
  - 인터페이스는 생성자를 가질 수 없다.
  - 인터페이스는 구현부가 있는 non-static 메소드를 가질 수 없고 추상 메소드와 static 메소드만 사용 가능하다.
  - 단, default 키워드를 사용하면 non-static 메소드도 작성 가능하다.
  - 인터페이스의 default 메소드
    - 의미: 인터페이스에 실제 구현이 포함된 메소드를 정의할 수 있게 함
    - 목적: 인터페이스에 새 기능을 추가하면서 기존 구현체들의 호환성을 유지
    - 특징: non-static 메소드이며 구현 클래스에서 재정의 가능
  - 인터페이스 안에 작성한 메소드는 묵시적으로 public abstract의 의미를 가진다.
  - 따라서 인터페이스의 메소드를 오버라이딩 해야 하는 경우 반드시 접근 제한자를 public으로 해야 오버라이딩이 가능하다.
  - 인터페이스 사용 이유
    - 추상 클래스와 비슷하게 필요한 기능을 공통화해서 강제성을 부여할 수 있다.
    - 자바의 단일 상속의 단점을 극복할 수 있다. 즉, 다중 상속이 가능하다.

## 💻 실습 예시

### Java
- [다형성](../src/main/java/com/chapter09_polymorphism/polymorphism)
- [추상 클래스](../src/main/java/com/chapter09_polymorphism/abstractclass)
- [인터페이스](../src/main/java/com/chapter09_polymorphism/interfaceimplements)
- [오늘의 실습 문제 : 커피 주문 시스템](https://github.com/SerahKim/java-coffee_order-projcet)

## ✍️ 오늘의 회고
- 오늘은 자바 객체 지향 프로그래밍에서 중요한 개념인 다형성, 추상화, 그리고 인터페이스에 대해 학습했다. 특히 다형성에서는 업캐스팅과 다운캐스팅의 차이점과 사용법을 명확히 이해할 수 있었다.
- 실습으로 진행한 커피 주문 시스템 프로젝트는 객체 지향 설계를 실제로 구현해보는 좋은 경험이었다. 특히 각 커피 메뉴를 자식 클래스로 만들고, 
공통 기능을 추상 클래스인 Coffee에서 정의해보면서 추상 클래스 사용 의도에 대해 다시 한번 생각해보았다.
- 이번 실습을 통해 객체 지향 설계를 코드에 실제로 녹여내는 과정에서 설계가 얼마나 중요한지 다시 한번 느꼈다. 클래스 간의 관계 설정, 공통 속성과 동작의 추출, 그리고 책임 분리가 프로그램의 유지보수성과 확장성에 큰 영향을 미친다는 점을 실감했다.
